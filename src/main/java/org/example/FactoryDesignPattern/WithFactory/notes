âœ… GOAL:
Letâ€™s simulate a real-world change:
â¡ï¸ Suppose the Sedan class is renamed to LuxurySedan.
Now let's see:

âŒ What would happen without Factory

âœ… What happens with Factory
âŒ Without Factory (Painful)
Original code:
Car car = new Sedan();

Now Sedan is renamed to LuxurySedan:

Car car = new LuxurySedan();  // âŒ You must change this EVERYWHERE in the codebase

â¡ï¸ Problem: You must manually go to every file/class where new Sedan() was written and change to new LuxurySedan().

âœ… With Factory (Clean & Easy)
Step 1: Factory Code (you only change here):

public class CarFactory {
    public static Car getCar(String type) {
        if (type.equalsIgnoreCase("sedan")) {
            return new LuxurySedan();  // ğŸ‘ˆ Only changed here!
        } else if (type.equalsIgnoreCase("suv")) {
            return new SUV();
        }
        return null;
    }
}

Step 2: Client code (no change required!):
Car car1 = CarFactory.getCar("sedan");
car1.drive();

ğŸ¯ ADVANTAGE (EXPLAIN IN INTERVIEW):
"Factory centralizes object creation logic. So if an implementation class changes (like Sedan â†’ LuxurySedan),
we update only the factory, not all the places that use that object.
It improves maintainability, flexibility, and reduces tight coupling."

ğŸ” BONUS: You can even change logic dynamically!
In the Factory, you can change object creation based on:

Config file

Environment

External API

if (ConfigReader.get("car.type").equals("sedan")) {
    return new LuxurySedan();
}
